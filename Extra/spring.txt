Lezione 1 - Introduzione 

Spring -> per applicazioni di tipo Enterprise (complesse, destinate al mondo aziendale). In questo contesto vi sono requisiti di: scalabilità, sicurezza, affidabilità, gestione di grandi quantità di dati. 

//Java EE (Enterprise Edition), divenuto Jakarta 

Java Beans -> componenti utilizzati per realizzare applicazioni Enterprise. 

Spring è un framework più leggero di Java EE, che invece aveva forte dipendenza con i Java Beans. Basato su classi POJO (Plain Old Java Object, più leggere) con utilizzo di Dependency Injection per la gestione delle dipendenze e utilizzando classi/interfacce riutilizzabili.

Spring è un framework modulare, possiamo scegliere le componenti necessarie per soddisfare i requisiti della nostra applicazione. C'è un Core con le funzionalità principali e una serie di microframework per le altre funzionalità non presenti nel Core. 

Framework opinionated -> framework in cui sono state prese delle scelte che dovrebbero essere adatte alla maggior parte dei casi d'uso. 

Classi POJO -> classi con campi, setter e getter, costruttori... Delle classi che non vanno a implementare interfacce particolari o estendere altre classi e pertanto estraibili e riutilizzabili ovunque. 

Spring cerca di ridurre l'accoppiamento tra i componenti (Loose Coupling) usando l'idea dell'Invertion of Control, implementato con la Dependency Injection. L'idea di base è che un componente che ha bisogno di un altro componente non deve essere strettamente connesso all'altro componente. In questo modo un componente non deve "portarsi dietro l'altro". 

Si utilizzano inoltre molte interfacce e meno implementazioni in Spring. 

Si fa un uso pesante delle Annotazioni in modo da avere un approccio più dichiarativo, dichiarando ciò che vogliamo ottenere. Non diciamo a Spring come fare il suo lavoro, ma semplicemente che abbiamo una necessità e lasciamo fare a Spring ciò che è necessario. 

Si possono utilizzare anche dei template per eliminare il boiler code (codice ripetuto).

Spring Boot permette la semplificazione ulteriore di applicazioni Spring. E' un modulo che semplifica ulteriormente un'applicazione Spring, ma non indipendente e fortemente legato al framework di base. 

--------------------------------------------------------------------------

Lezione 2 - Convention over configuration

Convention over configuration è l'approccio usato dal framework Spring. Inizialmente un progetto Spring andava configurato attraverso dei file .xml attraverso un approccio di programmazione dichiarativa. Sono state poi introdotte le annotazioni Java che hanno rimpiazzato l'approccio dei file .xml. 

Un'applicazione utilizzerà dunque una configurazione di tipo convenzionale, ovvero si impostano delle configurazioni di default che permettono di avere un'applicazione operativa in poco tempo, seguendo delle linee guide date dal team. Magari l'applicazione non è perfettamente aderente ai nostri requisiti, ma è operativo in un tempo minimo. 

Se ne può fare in seguito l'overriding delle configurazioni di base, in modo tale da adattare l'applicazione alle nostre necessità.

Starter -> contenitore di dipendenze.

Aggiungiamo alle dipendenze il modulo che vogliamo, un singolo starter. 

//default di framework security -> username: user, password: generata e visibile dai log della console 

Anche se l'applicazione non è come la vorremmo, è già funzionante e possiamo abilitare/disabilitare con le annotazioni le varie impostazioni. 

E' un partire da qualcosa di già fatto e modificarlo, anzichè partire da zero e fare tutto. 

--------------------------------------------------------------------------

Lezione 3 - Inversion of Control e Dependency Injection

Il problema delle dipendenze è alla base di questi concetti: immaginiamo di avere un classe Veicolo che utilizza al suo interno un'istanza della classe Motore (creandola con l'operatore New). Il Veicolo dunque utilizzerà anche delle funzionalità della classe Motore. Vi è dunque un accoppiamento forte tra la classe Veicolo e la classe Motore, infatti la classe Veicolo dipende dalla classe Motore (ha una dipendenza dalla classe Motore). Ciò comporta problemi anche in fase di testing. 

Inversion of Control (è un pattern): anzichè creare le dipendenze all'interno della classe che ne ha bisogno, la gestione di queste dipendenze viene delegata ad un framework al di fuori della classe. In questo modo la classe Veicolo avrà ancora bisogno della classe Motore, ma non ne creerà più un'istanza al suo interno. Con Inversion of Control la creazione di questa istanza che causa dipendenza viene invece effettuata al di fuori della classe Veicolo, con delega al framework. 

//Service Locator

Dependency Injection (possibile implementazione di IoC): il framework crea l'istanza di Motore e la inietta all'interno della classe Veicolo che ne ha bisogno. Ovviamente la classe Veicolo deve specificare che ha bisogno dell'istanza di Motore. Vi sono diversi tipi di iniezione in Spring: tramite costruttore, setter, ... 

In questo modo Veicolo non deve portarsi dietro la dipendenza, che verrà iniettata dal framework. 

//IoC è pattern, DI è implementazione 

Dependency Injection è la D dei principi SOLID.

Bean: classi il cui ciclo di vita è gestito da Spring. 

--------------------------------------------------------------------------

Lezione 4 - Bean 

Spring si basa sulla Dependency Injection, ovvero un meccanismo attraverso il quale si delega la gestione delle dipendenze al framework. 

Un Bean è un oggetto il cui ciclo di vita è gestito dal framework (in questo caso Spring). Un Bean è un'istanza di una classe che viene creata, gestita e distrutta dal framework. 

Il compito del programmatore è quello di dichiarare la necessità di utilizzo di determinati Bean e lasciarli gestire da Spring. 

Due modalità essenziali per dichiarare Bean:
- Classe annotata con @Component: andiamo a dire a Spring che quella classe è un componente e dunque Spring andrà a creare quella classe e gestirla con un application context. I Bean creati da Spring vivono dentro un IoC Container. E' necessario anche abilitare la scansione dei componenti per fare istanziare queste classi allo startup. 
//classe annotata con stereotipi 
- @Bean all'interno di una classe @Configuration: si crea una classe @Configuration per dire che rappresenta una classe di configurazione e all'interno di essa definiremo dei metodi annotati con @Bean in cui ciascun metodo va a istanziare con una new la classe di cui vogliamo ottenere un Bean. 

Di default Spring crea una singola istanza di un Bean (singleton), ma è anche possibile specificare la modalità per avere più Bean, gestibili attraverso il Bean Scope. 

Perchè usare @Bean se abbiamo @Component? La notazione @Component è utilizzabile solo se le classi scritte sono classi create da noi, ma non esterne. Se invece usiamo classi esterne usiamo @Bean. 

--------------------------------------------------------------------------

Lezione 5 - Bean (esempi pratici)

Partiamo avendo una classe POJO Student.

Avendo una classe: 

import org.springframework.context.annotation.Bean;
@Configuration
public class BeanConfig {
  @Bean(name = "student1") //senza specificare l'attributo prendeva il nome del metodo 
  public Student getStudent1() {
    return new Student("pinco", "pallino");
  }
}

Classe con il main:
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
//@Configuration
//@ComponentScan
public class SpringBeansExample {
  public static void main(String[] args) {
    AbstractApplicationContext ctx = new AnnotationConfigApplicationContext(BeanConfig.class);

    Student s1 = (Student) ctx.getBean("student1");
    //Student s1 = ctx.getBean("student", Student.class);

    for (String beanName : ctx.getBeanDefinitionNames()) {
      System.out.println("Bean --> " + beanName);
    }
    ctx.close();
  }
}

E' necessario avere il contesto, messo in ctx. getBeanDefinitionNames ritorna la lista dei nomi dei Bean creati dall'applicazione, anche quelli non creati da noi. Viene creata un'istanza anche dalla classe annotata con @Configuration.

Se rendiamo invece la classe POJO annotata con @Component e la classe principale SpringBeansExample l'annotiamo con @Configuration e @ComponentScan, allora funziona anche senza l'apposita classe di configurazione. 

@Component
public class Student {
  ...
}

Classe con il main:
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
@Configuration
@ComponentScan
public class SpringBeansExample {
  public static void main(String[] args) {
    AbstractApplicationContext ctx = new AnnotationConfigApplicationContext(SpringBeansExample.class);

    for (String beanName : ctx.getBeanDefinitionNames()) {
      System.out.println("Bean --> " + beanName);
    }
    ctx.close();
  }
}

In questo modo viene creato un Bean che è istanza della classe Student. 





























