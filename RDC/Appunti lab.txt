Lezione 01 - 28/10/22

Packet tracer -> Strumento di Cisco (Networking Academy) per training su amministrazione di reti, configurazione apparati, servizi, controllo degli accessi.

Socket Java -> Interfaccia per l'accesso ai servizi di rete 
	- programmazione di applicazioni distribuite (event-driven).
	- insieme di classi oer l'accesso ai servizi del trasporto all'interno di applicazioni.
	- di alto livello -> invisibili molti dettagli di sistema.


Packet tracer lavora a livello 2 e 3 dello standard OSI (Network 3 e Data Link 2) [in TCP/IP: Internet 3 e Data Link 2].
Socket lavora a livello 4 dello standard OSI e di Internet.

Cisco Packet Tracer -> Emulatore di reti -> Permette di disegnare la nostra rete e assicurarci del suo funzionamento con notevole realismo. 

Router (Livello 3), Switch (Livello 2).

In CPT ci sono anche i modelli che Cisco crea irl (indicati dal codice sotto al dispositivo).

Applicazioni distribuite: riguardano il livello 4 (Socket). 

Socket Java danno solo accesso al trasporto; altre socket danno accesso anche a livelli minori come network (Socket C).

Materiale -> Slide del docente, contenuti relativi alle lezioni (Ariel: file .pkt, sorgenti Java, audio/video relativi a svolgimento di esercizi, lezioni registrate), dispensa Packet Tracer.

Anche syllabus (calendario delle lezioni dipende dalla parte di teoria).

Esame (CPR: calcolo parametri di rete, + PT: configurazione pacchetti di rete, + JS: sviluppo di applicazione distribuita) -> voto = ((0.25CPR + 0.25PT + 0.5JS) * 0.4) + (Teoria * 0.6) ; //tutte nello stesso appello (che branco di clown sti prof) 

Iniziamo con qualcosa di packet tracer (8.2.0).

Livello Fisico: cablature, cavi cross e straight, hub
Livello Data-Link: 
	- bridge, switch, configurazione VLAN 
	...
	
Configurazione Cisco: Options -> Preferences -> Miscellaneous 
	Configurazione opzioni uso memoria: Auto Clear Event List
	Per fare fronte a blocchi applicazione: Auto File Backup Interval 
	
Logical -> Spazio non ha caratteristiche, ci possiamo mettere ciò che vogliamo.
Physical -> Posso rappresentare una rete fisica e collegarmi a reti esterne che ancora non possediamo. 

In alto strumento di selezione per selezionare. In basso a sinistra per scegliere End Device, Connection, Network Devices, Components; ciascuno con altre sottocategorie (nella lista che compare sotto).

Lente di ingrandimento -> informazioni extra sul dispositivo.

Strumento di delete -> Cancella dispositivo.

Icona 5 -> Per aggiungere note. 

Palette di dialogo con possibile selezione di forma e colore -> per evidenziare zone della rete che sono insieme ad esempio. 

Aggiungiamo ripetitore Hub (permette di modificarfe il segnale). Hover sul dispositivo e mostra informazioni (o ci clicco sopra e mostra com'è fisicamente). All'interno ha 6 moduli (6 possibili tipi di porte). Le porte sono classificate con due o tre lettere (CFE -> Copper Fast Ethernet). Posso spegnere la corrente e poi aggiungere/rimuovere moduli nelle porte.

Per collegare Hub andiamo in Connection.

Posizioni da destra a sinistra (livello fisico) 0,1,2,3,...

Connessione automatica è pericolosa. Tra router e router ad esempio crea in automatico una connessione seriale (passa un bit alla volta in rete). Per vedere cosa stiamo collegando -> Options -> Preferences -> Interface -> Always show port labels in logical space.

Doppio cerchio (uno in, uno out) -> Fibra ottica.

Triangoli rossi -> non va la connessione (verdi -> va).

Hub è apparato plug-and-play, non necessita configurazione. Router invece necessita di configurazione.

Porta ha anche numero espresso. 

Da visione fisica -> config -> interface che ci serve -> posso accenderla. 

---------------------------------------------------------------------------------------------------------------------

Lezione 02 - 04/11/22

Lavoriamo su packet tracer. Icone: Hub, switch, router, bridge. Che differenza c'è fra le connessioni? (Occhio a usare la scelta automatica delle connessioni).

Router -> dal francese, vuol dire strada. 

Link possono essere rappresentati tramite un cavo dritto o un cavo cross. 

Cavi con terminatore RJ-45 -> cavi di rete. 

Esistono anche i repeater (ripetono il segnale).

Twisted pair cable -> 8 cavetti in rame (8 colori -> 4 di colore e 4 associati di colore+bianco).

Fibra ottica -> all'interno viaggia un segnale luminoso, ma anche il sole emette luce, per cui se i cavi della fibra ottica vengono esposti alla luce, possono subire un'alterazione dei dati che vengono trasferiti. A tale scopo, la superficie della fibra è specchiata, in modo tale da avere un'isolazione dalle interferenze esterne. 

I cavi in rame hanno anch'essi una doppia guaina per isolare il segnale, ma non è efficiente a livello di isolazione come la fibra ottica, infatti i cavi in rame sono più influenzabili dai campi elettromagnetici esterni.

Hub ha più interfacce di rete, in cui può entrare un cavo con terminatore RJ-45. // (PT-Hub su PT)

Un Hub non ha nessuna intelligenza se non quella hardware. Hub fa broadcast, su qualunque delle interfacce fa il segnale. Il repeater hub prende il segnale, lo ripulisce e lo manda su tutte le interfacce tranne quella da cui è arrivato il dato. 

Bridge e switch lavorano invece a livello data-link, ovvero il livello in cui realizzo un servizio connection-oriented con un dispositivo che è "adiacente" al nostro. Bridge e switch sanno fare indirizzamento di livello 2, ovvero indirizzare/identificare in reti punto-punto l'apparato che sta dall'altro lato del cavo, in reti broadcast ogni apparato che sta nella LAN (con indirizzi di livello 2). A livello 2 vengono anche implementate le politiche di accesso al mezzo (per evitare sovrapposizione di segnali). 

//interferenze sinusoidali -> due sinusoidi si alterano a vicenda, sporcando il segnale. 

Bridge -> come un ponte ha solo due estremi -> ha solo due slot, può collegare soltanto due apparati in maniera diretta.

Switch può invece avere molte porte. 

Bridge collega solo reti omogenee, switch collega anche reti non omogenee. 

Un bridge collega solo reti che usano protocolli di livello data-link (2) omogenei.

PT: Options -> Preferences -> General -> Always show port labels. 

Collegamento seriale ha "zigzag", non vuole vedere che viene usato il collegamento seriale (?). 

Cablature: UTP: 
	- pin 1 (arancione+bianco) e 2 (arancione) -> invio
	- pin 3 (verde+bianco) e 6 (verde) -> ricezione 
	
Solo questi 4 cavi degli 8 vengono usati nelle reti ethernet e fast ethernet. 

Tra apparati di livello diverso usiamo cavi straight, cross altrimenti (ad esempio tra pc e router -> cross). Tra apparati di livello 1-2 -> cross. 

PIN:
Straight:			Crossed: 
1- WO				WG
2- O				G
3- WG				WO
4- BL				WBR
5- WBL				BR	
6- G				O
7- WBR				BL
8- BR 				WBL

(W -> white, O -> orange, G -> green, BL -> blue, BR -> brown).

In questo modo in collegamento con cavi crossed i pin di invio 1 e 2 (WO e O) entrano nei pin di ricezione 3 e 6 (WG e G), che sono rispettivamente 1 e 2 in porta di ricezione. [...] 

Esercizio sulle cablature: per ogni possibile coppia di dispositivi, li connettiamo. 

				Hub 		Switch		Router 		Workstation
Hub				Cross		Cross		Straight 	Straight	
Switch			Cross		Cross		Straight	Straight 
Router			Straight	Straight	Cross		Cross	
Workstation		Straight 	Straight 	Cross		Cross

PC ha solo due porte: Bluetooth e fast ethernet. Entrambe le porte hanno un MAC address (Medium Access, sottolivello del data-link), usato per identificare un dispositivo presente nella LAN. 

Connettere due bridge con cavo cross genera i cerchi arancioni sulle porte, che poi diventano verdi da soli (?). 

Bridge ha apparato di livello 2. I due bridge alla connessione si parlano e si accordano. Questo richiede tempo, pertanto alla connessione necessitano di "un tempo di setup". //questo usando il realtime, se usiamo simulation invece possiamo avanzare di evento in evento (o tornare indietro) e far andare avanti il tempo con continuità evento per evento.
I bridge (o switch) si scambiano messaggi di livello 2. 

Interfaccia dei router deve essere attivata, altrimenti non funzionano. 

Numerazione interfacce: prima cifra -> numero di slot fisico della scheda, seguita da / , seconda cifra -> numero di posizione di quel tipo di interfaccia sulla scheda. Slot si contano da destra a sinistra. 

Router è dispositivo che pretende che su ognuna delle sue interfacce di rete vi sia una rete diversa, il che implica che al router vada detto quale rete è su quale interfaccia. 

Usare nella shell: ping (localhost) 

Come argomento ping prende l'indirizzo di qualche cosa, ad esempio: ping www.unimi.it

In Simulation possiamo scegliere quali eventi vogliamo che vengano mostrati nella lista degli eventi. Scegliamo ICMP (richieste e replys).

Diamo indirizzi a oggetto di livello 3 -> Config -> interfaccia -> 192.168.0.1 (ad esempio). 

Vado su Add simple PDU e assegno il pacchetto al pc per farlo inviare all'altro pc (P). Schiacciando sul "messaggio" si possono vedere le informazioni del PDU.

Assegnare ad ogni EndSystem un IP.

Se due dispositivi hanno lo stesso IP, il source non manderà nemmeno il pacchetto, perchè penserà che sia destinato a sè stesso (e dunque è già arrivato). 




----------------------------------------------------------------------------------------------------

Lezione 3 - 08/11/22 

Per fare funzionare i ping, devo dare degli indirizzi IP alle macchine (assegnati nella pagina config -> interfaccia relativa e cambiare ipv4).

help ping -> mostra opzioni per cambiare frequenza e lunghezza dei pacchetti inviati nel ping.

All'interno di una LAN lavoro solo a livello 2.

Se schiaccio sul PDU (messaggio scambiato) mostra le informazioni del messaggio. 

Grazie al protocollo ARP in scambio da laptop-switch-pc, si riesce a capire che il dispositivo a cui inviare il messaggio è nella LAN e viene tradotto dunque in MAC (?). 

Router essendo di livello 3 necessita di essere configurato. 

Per poter parlare a livello 3 (uscire dalla LAN), è necessario il router e che l'end-system abbia un gateway di default settato, ovvero l'indirizzo che daremo al router.

Il gateway deve avere un indirizzo con primi 3 numeri quelli che identificano la rete: 192.168.0.x -> 192.168.0.254 e quindi anche sul router la fastethernet relativa viene chiamata come quella del PC, o il PC non può uscire dalla LAN.

Se a un'interfaccia fastEthernet del router do un indirizzo già esistente nella rete ho un errore di sovrapposizione -> si sovrappone con la stessa rete 192.168.0.x -> router vuole reti diverse -> 192.168.1.1 (ok).

Filtro eventi usando solo ARP e ICMP. Ora il ping tra server-router-endsystem funziona. 

Router serve a poter far comunicare LAN diverse attraverso l'utilizzo di gateway. 

Router sono apparati intelligenti che costano molto. Switch invece non sono intelligenti e costano molto di meno. 

Router ha processo di apprendimento. 

Non attaccare mai i PC alle interfacce dei router direttamente (passare per switch, in modo di formare LAN).

Per vedere la tabella di routing di un router -> inspect sul router -> routing table. 

Slide 18 esercizi.

ICMP -> solo ping.

Bridge è apparato di livello 2 -> La sua ARP table è vuota (non capisce livello 3), ma la sua MAC table si può riempire invece. Con i passaggi di pacchetti il Bridge "impara" e riempie la sua MAC table. 

3 bridge o 3 switch a triangolo -> fanno anello e continuano a far girare messaggi -> rompono l'anello non attivando una delle interfacce. 





----------------------------------------------------------------------------------------------

Lezione 4 - 11/11/22

Slide 2 del file PT1. 5 PC tutti collegati a uno switch.

Attivo ICMP per vedere i ping. 

Gli switch imparando dove sono situati gli endpoint possono rompere i domini di collisione. 

Algoritmo di Dijkstra -> ottimo per calcolare il miglior cammino in un grafo, ma ha la necessità di conoscere l'intera topologia del grafo. Ha costo di n² (n^2), dove n è il numero di nodi del grafo. Viene usato in addressing (?). 

Hub, Switch e Bridge sono apparati plug-n-play. Per rimanere a livello due, ma avere due reti distinte logicamente (giallo e blu), dobbiamo istruire gli switch. Click sullo switch -> tab configurazione -> Switching -> VLAN database. Nel database ci sono già valori predefiniti (1 -> default). Gli altri sono dei protocolli di livello 2 (fddi fiber con topologia ad anello).

Le VLAN hanno due valori -> un indice numerico e un nome. 

Una buona pratica nel dare il nome alle VLAN è quella di aggiungere nel nome l'identificare numerico della VLAN.

Spesso si associano delle VLAN a dei colori. 

Istruisco tutti gli switch aggiungendo al loro VLAN database le VLAN espresse tramite il relativo numero e il relativo nome. 

(Options -> Interface -> Always show port labels in logical workspace ON).

Poi bisogna dire che all'interfaccia dello switch possono accedere solo frame che fanno parte della vlan dello specifico numero. 

Cambiate le VLAN accettate dall'interfaccia, lo switch si riconfigurerà. 

Ancora non funzione il passaggio tra i due switch perchè gli switch sono anche loro con una VLAN (1, default). 

Devo dire che il link collegato alla fastethernet del link permette l'accesso ai frame arancioni e viceversa sull'altro switch. 

Per far passare anche i frame blu però devo anche poter utilizzare altre porte in più.

Protocollo 802.1Q modifica il protocollo ethernet in modo tale che le ethernet hanno un formato del frame leggermente diverso nel quale viene aggiunto un Header 802.1Q. Questo header contiene anche il VLAN ID. 

Standard 802.1Q -> protocollo di trunking. 

Dallo switch -> config -> interface -> cambio il protocollo in protocollo di trunking. 

ARP è protocollo di livello 2 e mezzo (capisce sia indirizzi di livello 2 che di livello 3). 

Apparati di rete hanno il loro Sistema Operativo -> IOS -> possiamo andare a lavorare direttamente al prompt di shell del nostro apparato dalla sezione CLI (Command Line Interface). 

CLI ha due livelli di accesso: utente (consente la visualizzazione della configurazione, ha simbolo di > nel prompt) e privilegiato (consente la modifica della configurazione, ha simbolo di # nel prompt). //i due livelli di accesso hanno due password differenti 

Al prompt di uno switch -> ? -> fa vedere comandi a disposizione si uno switch. 

disable -> fa tornare in modalità utente, enable -> fa entrare in modalità privilegiata. 
ping -> ICMP, manda un messaggio echo. 
traceroute -> sfrutta icmp per capire il percorso eseguito da un pacchetto. 
show -> fa vedere la configurazione 

"comando ?" -> opzioni del comando 

show interfaces fastEthernet 0/1   			/7fa vedere caratteristiche dell'interfaccia 0/1



------------------------------------------------------------------------------------------------------

Lezione 05 - 15/11/22 

Interfaccia grafica per LAN virtuali attraverso CLI (termine dell'ultima lezione). Router non sono plug-n-play, tipicamente necessitano di una configurazione prima di poter funzionare. 

Abbiamo 3 modi per configurare un apparato: 
- Interfaccia grafica (pensata per utenti non esperti o pratici).
- Command line IOS (Internet-working Operative System, proprietario di Cisco, ma anche altre aziende hanno OS analoghi). Consente di riconfigurare un'ifc lasciando operative le altre.
- tftp (Trivial File Transfer Protocol, scaricamento di file editato off-line, tipicamente gli amministratore di rete tengono dei file di configurazione già testati e funzionanti).
.

Posso entrare in modalità privilegiata solo se sono già in modalità utente (come sudo in Linux, devo già essere dentro come utente) (> -> utente, # -> privilegiata). . 

Comandi in CLI di switch: 
? -> comandi disponibili 
show ? -> help per il comando show 

Filtro di simulazione -> Misc -> STP 

In una rete con loop tra switch, dei dati potrebbero girare indefinitivamente. Grazie a STP (Spanning Tree Protocol) gli switch cercano di scoprire quali apparati hanno vicino. Dopo un certo punto due link diventeranno verdi, ma il loop non permetterà al terzo switch di avere link verde -> un'interfaccia a caso verrà disabilitata per interrompere il loop. In questo modo il pacchetto prenderà però una strada più lunga facendo ad esempio un hop in più tra gli switch. 

Nella realtà gli amministratori di rete creano dei loop, poichè in caso di guasto di uno switch continuo ad avere una rete funzionante (al guasto dello switch non vi è più loop e lo STP permette che l'interfaccia dello switch in precedenza disabilitato verrà resa funzionante. 

show permette di vedere anche la MAC address table. 

Secure shell (ssh) e Secure Socket Layer (ssl) vengono usati per comunicazione cifrata. 

show in fa 0/1 -> mostra interfaccia fastethernet 0/1 

enable -> vado in modalità privilegiata.
disable -> torno in modalità utente. 

ctrl-shift-6 per fare l'abort dell'esecuzione di un comando. (ctrl-alt-6 per linux) 

show ? -> in modalità privilegiata fa ovviamente vedere più roba. 

show access-lists -> mostra le ACL usate per controllare il traffico su una interfaccia. 

show boot -> configurazione di cosa fa l'apparato al boot. 

show interfaces fa 0/1 

show running-config -> per vedere la configurazione di startup dell'apparato. 

show snmp -> simple network management protocol -> incapsula i comandi della CLI per farli arrivare al dispositivo (?) 

show spanning-tree -> mostra la topologia ad albero costruita seguendo lo STP. 

? in modalità privilegiata -> per vedere tutti i comandi possibili in modalità privilegiata. 

exit / logout / disable -> fanno uscire dalla modalità privilegiata 

per annullare un comando sbagliato possiamo fare -> no command 

write memory -> scrive la running configuration in memoria 

do command -> per eseguire comando con modalità differente da quella attuale

VLAN virtuali da CLI:

vlan ?

vlan database ?

facendo vlan database cambia anche il prompt, che dice che sono entrato in un sottomodulo, che può contenere diversi comandi. 

prompt diventa Switch# -> Switch(vlan)# 

vlan database è però deprecato, quindi non lo usiamo.

per creare le vlan usiamo il comando configure terminal 

configure terminal / conf t / configure in terminal 

prompt diventa Switch(config) 

show non c'è, diventa necessario scrivere "do show" 

se eseguo vlan ? -> dice che chiede il vlan id 

vlan 10 ? -> vlan 10 -> entro in un nuovo sottomodulo.

name orange_10

exit -> ora il cambiamento viene effettuato ed è visibile nel vlan database. 

vlan 11 -> name cyan_11 -> exit 

do show vlan -> mostra il vlan database

le vlan sul pc servono in modalità access, non trunk. 

interfaces fastEthernet ?

interface fastEthernet 0/1 

shutdown 

no shutdown 

switchport ? 

switchport mode ? 

switchport mode access 

switchport access vlan ? -> vuole id del vlan 

switchport access vlan 10 -> exit

interface fastEthernet 1/1 -> switchport mode access -> switchport access vlan 11 -> exit 

eccetera sull'altro switch 

per l'interfaccia che deve fare trunking bisogna fare switchport trunk allowed vlan 10 11 (oppure) switchport trunk allowed vlan add 20 

interface fastEthernet 3/1 -> switchport mode trunk -> eccetera

posso anche fare switchport trunk allowed vlan remove x 




-------------------------------------------------------------------------------------------------

Lezione 06 - 18/11/22

Argomento della lezione è IP addressing (IPv4). 

Indirizzo di network -> 32 bit unsigned. Dotted notation: es: 159.149.139.9 . Indirizzo deve essere globalmente unico. 
5 Schemi di assegnazione degli indirizzi:
- class-based subnetting vs classless addressing (CIDR)	
- subnetting
- network address translation (NAT)
e poi IPv6. 

Class-based addressing: indirizzo IP contiene network ID + host ID. //bit meno significativi -> indicano host, più significativi indicano rete:
- hostID = 0 -> stessa rete 
- netID = 0 -> l'host indicato sulla stessa rete della source 
- tutti '1' -> broadcast sulla rete della sorgente 
- hostID tutti '1' -> broadcast sulla rete destinataria 

5 classi di indirizzi: [slide] 

Indirizzi particolari:
- 0.0.0.0 -> questo network 
- 255.255.255.255 -> broadcast su questo network (TTL=1 ???)
- <netID>.<00...00> -> indirizzo base della rete 
- <netID>.<11...11> -> broadcast sulla rete target 
- tutti i valori intermedi possono essere usati per gli apparati

Se usiamo x bit per netID e y (32-x) bit per hostID, allora la netmask è composta da x bit a '1' seguiti da y bit a '0'. 

Entry delle tabelle di instradamento: <dest, netmask, oif, metric, flags> -> facendo bitwise AND fra pkt.dest e netmask -> ottengo dest . 

altrimenti 2^32 linee nelle routing table -> mediamente n/2 per trovare ciò che voglio in tabella disordinata -> 2^31 .

Possiamo diminuire questo numero ragionando su come viaggiamo normalmente -> gerarchia di livelli di apparati. 

Esercizi:
- 127.128.129.192 -> 0111 1111 . 1000 0000 . 1000 0001. 1100 0000 
- 20.148.67.123 -> 0001 0100 . 1001 0100 . 0100 0011 . 0111 1011 
- 218.160.179.60 -> 1101 1010 . 1010 0000 . 1011 0011 . 0011 1100 
- 87.194.104.77 -> 0101 0111 . 1100 0010 . 1011 1000. 0100 1101 

- 0101 1011 . 0111 0110 . 0010 1111 . 1001 1111 -> 91.118.47.159
- 0000 1100 . 1000 1000 . 0111 0010 . 0011 0111 -> 12.136.114.55
- 1110 0111 . 0010 0110 . 0110 0100 . 0110 0000 -> 231.38.100.96

Broadcast, netmask, 2 indirizzi apparati per:
- 15.0.0.0 -> classe A (0...) :
	- Broadcast: 15.255.255.255 
	- Netmask: 255.0.0.0 (tira fuori solo netID con AND bitwise, maschera le differenze tra gli apparati)
	- Indirizzi apparati (primo e ultimo): 15.0.0.1, 15.255.255.254 
	
- 137.149.0.0 -> classe B (10...) :  
	- Broadcast: 137.149.255.255 
	- Netmask: 255.255.0.0 (tira fuori solo netID con AND bitwise, maschera le differenze tra gli apparati)
	- Indirizzi apparati (primo e ultimo): 137.149.0.1, 137.149.255.254 

- 215.151.59.0 -> classe C (110...) :  
	- Broadcast: 215.151.59.255 
	- Netmask: 255.255.255.0 (tira fuori solo netID con AND bitwise, maschera le differenze tra gli apparati)
	- Indirizzi apparati (primo e ultimo): 215.151.59.1, 215.151.59.254 	
 

CIDR -> Classless -> indirizzo di base di rete è x.y.w.z/n -> n indica i bit usati per netID, indipendentemente dalla classe. In indirizzo base gli ultimi 32-n bit devono essere '0'.

Togliamo il confine stabilito dalle classi, il "confine" della rete è determinato dal /n in CIDR.



--------------------------------------------------------------------------------------------------

Lezione 07 - 22/11/22

Usare un routing classless conviene. 

Indirizzo base di rete: z.y.w.z/n, dove n indica il numero di bit per netID, indipendetemente dalla classe. Nell'indirizzo base gli ultimi 32-n bit devono essere 0.

Es: 137.87.47.96/28 -> 32-28 -> 4 bit di hostid -> x.x.x.96 -> x.x.x. 0110 | 0000 (primi 4 sono ancora per netID, ultimi 4 sono per hostID). La rete può ospitare 2^4 apparati -1 (per quella indicante la rete) -1 (per quella indicante il broadcast sulla rete). 

Le classi C poichè poco volute e utilizzate sono state raggruppate in insiemi da usare come spazio contiguo di indirizzi:
- 194.0.0.0 - 195.255.255.255 -> Europa
- 198.0.0.0 - 199.255.255.255 -> Nord America 
- 200.0.0.0 - 201.255.255.255 -> Centro-Sud America 
- 202.0.0.0 - 203.255.255.255 -> Asia e Australia
.

Questa cosa facilita anche l'instradamento dai parte dei router -> se sono in NA e vedo un pacchetto con destinazione 194.x.x.x -> so già che devo instradare verso l'EU, mi basta guardare il primo ottetto; la maschera è come se fosse /8.

Sulle regioni possiamo fare reti di classe C -> ultimo ottetto per hostID -> 256*256 (ottetto 1 e 2) -> 131072 possibili classi C per ogni regione, quindi circa 33554432 indirizzi di host. 

Esempio su slide 12/44 -> maschera produce sempre l'indirizzo che è ricordato nella routing table come indirizzo base. In EU tutti devono sapere dove quell'indirizzo debba andare. La cardinalità dei gruppi è sempre una potenza di 2. 

Esercizio: indirizzamento a livello 3 dell'apparato: 111.162.136.87 (/12) 
apparato 111.162.136.87 /12 -> 12 bit 1 -> mask = 1111 1111 . 1111 0000 . 0000 0000 . 0000 0000 = 255.240.0.0 (mask)
perciò: 
	0110 1111 . 1010 | 0010 . 1000 1000 . 0000 1100 = 111.162.136.87 /12 (apparato)
	1111 1111 . 1111 | 0000 . 0000 0000 . 0000 0000 = 255.240.0.0 (maschera) 
	0110 1111 . 1010 | 0000 . 0000 0000 . 0000 0000 = 111.160.0.0 (indirizzo base della rete)
	0110 1111 . 1010 | 1111 . 1111 1111 . 1111 1111 = 111.175.255.255 (broadcast). 
	Range di apparati: 111.160.0.1 - 111.175.255.254 
	
Esercizio: indirizzamento a livello 3 dell'apparato 206.191.1.207 /25 
Apparato -> 206.191.1.207 -> 25 bit a 1 di maschera 
	1100 1010 . 1011 1111 . 0000 0001 . 1 | 100 1011 = 206.191.1.207 /25 (apparato) 
	1111 1111 . 1111 1111 . 1111 1111 . 1 | 000 0000 = 255.255.255.128 (mask) 
	1100 1010 . 1011 1111 . 0000 0001 . 1 | 000 0000 = 206.191.1.128 /25 (indirizzo base) 
	1100 1010 . 1011 1111 . 0000 0001 . 1 | 111 1111 = 206.191.1.255 (broadcast)
	Range: 206.191.1.129 - 206.191.1.254 

Esercizio: indirizzamento a livello 3 dell'apparato 57.47.77.159/11 
11 bit a 1 di maschera 
	0011 1011 . 001 | 0 1111 . 0100 1101 . 1001 1111 = 57.47.77.159 /11 (apparato)
	1111 1111 . 111 | 0 0000 . 0000 0000 . 0000 0000 = 255.224.0.0 /11 (mask)
	0011 1011 . 001 | 0 0000 . 0000 0000 . 0000 0000 = 57.32.0.0 /11 (base)	
	0011 1011 . 001 | 1 1111 . 1111 1111 . 1111 1111 = 57.63.255.255 (broadcast) 
	Range: 57.32.0.0 - 57.63.255.255 
.

Esercizio: indirizzamento a livello 3: 4 apparati: 
137.116.36.31, 137.116.32.205, 137.116.39.43, 137.116.35.112 -> trovare indirizzo base per rete minima. 
Hanno tutte i primi 2 ottetti uguali, guardo il terzo ottetto di tutti:
	36 -> 0010 0100 
	32 -> 0010 0000 
	39 -> 0010 0111 
	35 -> 0010 0011 
	la parte comune sono 5 bit -> 0010 0 | 000 -> indirizzo base con terzo ottetto -> 32 -> 5 bit di netID, 3 di hostID ->
	mask è di 16+5 bit -> 21 bit 
	137.116.32.0 /21 -> indirizzo base 
	255.255.248.0 -> mask
	137.116.39.255 -> broadcast
.

Router pretende che le sue interfacce abbiano ciascuna una rete diversa. Bisogna anche tenere un indirizzo extra da usare come gateway. 
Perciò tutti i dispositivi sono: end systems + gateway + broadcast + base. Per ogni subnet scegliere potenza di 2 minima per indirizzare tutti i dispositivi. 

In PT assegnare gli opportuni indirizzi a interfacce router e ricordarsi di mettere a ON l'interfaccia. Le interfacce di un router devono essere tutte su reti diverse. 

Per ogni host: assegnare l'opportuno indirizzo all'interfaccia di rete, indicare come indirizzo gateway l'indirizzo del router associato all'interfaccia appartenente alla stessa subnet dell'host. 

Virtualmente solo 30 dimensioni possibili di rete -> 30 punti di taglio da x.y.w.z/1 a x.y.w.z/30 . 

Slide 19/44. 

Best practice: il gateway ha sempre il primo oppure sempre l'ultimo indirizzo usabile.

Tabella progettazione reti:
INFO 				| 
INDIRIZZO BASE 		| 
INDIRIZZO BROADCAST | 
INDIRIZZO GATEWAY 	| 
PRIMO IP 			| 
ULTIMO IP 			| 
NETMASK 			| 
//WILDCARD 			| 
NOTE 				| 	

Es: 2 host connessi da cavo cross: rete 10.0.0.0/29
INFO 				| 2 pc 
INDIRIZZO BASE 		| 10.0.0.0/29 
INDIRIZZO BROADCAST | 10.0.0.7
INDIRIZZO GATEWAY 	| //in questo caso non vi è alcun gateway -> dovremmo dare l'indirizzo di un router 
PRIMO IP 			| 10.0.0.1 
ULTIMO IP 			| 10.0.0.6
NETMASK 			| 255.255.255.248
//WILDCARD 			| 
NOTE 				| 3 bit -> 6 indirizzi 

Es: 4 host + 1 hub, rete 192.168.90.0/27 -> 192.168.90.0, 4° ottetto con 3 bit di netID e 5 di hostID
INFO 				| 4 host, 1 hub 
INDIRIZZO BASE 		| 192.168.90.0/27
INDIRIZZO BROADCAST | 192.168.90.31 
INDIRIZZO GATEWAY 	| (*) 
PRIMO IP 			| 192.168.90.1
ULTIMO IP 			| 192.168.90.30 
NETMASK 			| 255.255.255.224
//WILDCARD 			| 
NOTE 				| 4 apparati + indirizzo base + broadcast -> 6 valori -> 3 bit necessari 

INFO 				| 
INDIRIZZO BASE 		| 
INDIRIZZO BROADCAST | 
INDIRIZZO GATEWAY 	| 
PRIMO IP 			| 
ULTIMO IP 			| 
NETMASK 			| 
//WILDCARD 			| 
NOTE 				| 	




-------------------------------------------------------------------------------------

Lezione 08 - 25/11/22

Subnetting -> suddivisione logica di reti grandi -> per ridurre dimensioni tabelle instradamento interne a organizzazione. (Astrazione interna, dall'esterno non si notano differenze).

Subnet mask -> tutti i bit a 1 per network e subnet address; tutti i bit a 0 per host address. A un router in questa rete interessa avere tante entry quante lo stesso numero di bit a 0.

<network address, 0> -> rete remota 
<0, host address> -> host in rete locale
<0, subnet address, 0> -> host in un'altra subnet della stessa rete locale
<0, 0, host address> -> host in subnet locale 

Esempio: rete di classe B 162.148.0.0/16 -> 65534 host. 
Per dividerla in sottoreti ognuna comprendnete massimo 100 host: 
per hostID necessito di 7 bit -> 128 host possibili (-2).
per netID rimangono 16-7 bit -> 9 bit -> 512 sottoreti possiibili.

Dimensionamento sottoreti: [Slide 31/44]
Rete 192.168.20.96/27 -> 4° ottetto: 011 | 0 0000 
Subnet verde: 4 host + 1 router + broadcast + rete -> 7 indirizzi -> 3 bit
	4° ottetto: 011 | 00 | 000 , zona centrale è per il subnetID
	netmask: 1111 1111 . 1111 1111 . 1111 1111 . 111 | 11 | 000 -> 255.255.255.248
	base: 192.168.20. 011 | 00 | 000/29 -> 192.168.20.96/29 
	broadcast: 192.168.20. 011 | 00 | 111 -> 192.168.20.103
	Range: 192.168.20.97 - 192.168.20.102
	
Subnet arancione: 2 host + 1 router + broadcast + base -> 5 indirizzi -> 3 bit -> sarà /29 
	4° ottetto: 011 | 01 | 00 
	netmask: 255.255.255. 111 | 11 | 000 -> 255.255.255.248 
	base: 192.168.20. 011 | 01 | 000 /29 -> 192.168.20.104/29
	broadcast: 192.168.20. 011 | 01 | 111 -> 192.168.20.111
	range: 192.168.20.105 - 192.168.20.110 
	

Altro esempio: indirizzo base 192.168.20.96/27
Subnet S1 con 5 apparati, subnet S2 con 14 apparati (inclusi router) 
S1: 5 apparati + broadcast + base -> 7 indirizzi -> 3 bit 
	netmask: 255.255.255.248 (poichè /29)
	base: 192.168.20. 011 | 00 | 000 -> 192.168.20.96 
	broadcast: 192.168.20. 011 | 00 | 111 -> 192.168.20.103
	gateway: 192.168.20.97
	range: 192.168.20.98 - 192.168.20.102 
	
/*
S2: 14 apparati + broadcast + base -> 16 indirizzi -> 4 bit -> (/28) 
	netmask: 255.255.255. 111 | 1 | 0000 -> 255.255.255.240 
	base: 192.168.20. 011 | 01 | 000 -> 192.168.20.104 /28 //così non va bene!
	broadcast: 192.168.20. 111 | 1 | 1111 -> 192.168.20.119
	gateway: 192.168.20.105 
	range: 192.168.20.106 - 192.168.20.118
*/
	
ma non funziona così -> tutti indirizzi all'interno della stessa rete devono avere la stessa netid e stessa quantità di subnetID bits. In quel caso due host in S2 appaiono in due reti diverse!

Regola dell'allineamento: Una rete di dimensione 2^n (ovvero che contenga 2^n indirizzi) può iniziare solo a intervalli regolari multipli di 2^n (a posizioni pari a k*2^n per k >= 0); ovvero il primo indirizzo disponibile nello host address range deve essere composto da tutti 0 negli ultimi n bit per qualsiasi sottorete. 

S2 diventa: (bisogna farla iniziare a un multiplo di 2)
S2: 14 apparati + broadcast + base -> 16 indirizzi -> 4 bit -> (/28) 
	netmask: 255.255.255. 111 | 1 | 0000 -> 255.255.255.240 
	base: 192.168.20. 011 | 1 | 000 -> 192.168.20.112 /28
	broadcast: 192.168.20. 111 | 1 | 1111 -> 192.168.20.127
	gateway: 192.168.20.113
	range: 192.168.20.114 - 192.168.20.126 
.

Alternativa: euristica -> (come fare una valigia) -> si inizia dalla subnet più grande e via via procedendo in ordine decrescente. 

Prima farei S2, poi S1. 

Bestpractice: se hanno stessa dimensione -> si va in ordine alfabetico (a parità di lunghezza di maschera, vado in ordine alfabetico). 

Con euristica non si lasciano buchi, ma con regola dell'allineamento possono crearsi buchi. 

Può capitare che l'euristica faccia anche applicare la regola dell'allineamento (è una proprietà dell'aritmetica binaria), ma non è detto che succeda.

Recap di alcune proprietà:
- La parte di hostID dell'indirizzo base deve essere composta solo da bit a 0. 
- Il primo indirizzo usabile è sempre dispari; l'ultimo indirizzo usabile è sempre pari. 
- L'indirizzo broadcast è sempre dispari. 
- I netID delle diverse sottoreti, espressi in binario, sono sempre tutti differenti e non sovrapponibili in almeno un bit. 

Ordinamento usato dagli amministratori: longest prefix matching -> prima le reti con la n più grande. 


Esercizio [Slide 42/44]:
10.11.160.0/24 -> rete di PMI, composta da:
- A -> Amministrazione -> 25 host
- G -> Gestione ordini -> 14 host 
- K -> Marketing -> 28 host
- M -> Magazzino -> 9 host
- R -> Reparto produzione -> 58 host 

Con euristica:
	Ordine di quali reti sono più grandi: R (58), K (28), A (25), G (14), M (9), a ciascuna vanno aggiunti: base, gateway, broadcast.
	 
	R: -> 58+3 -> 61 -> 2^6 = 64 -> 6 bit -> /26
		base: 10.11.160. 00 | 00 0000 -> 10.11.160.0 /26
		netmask: 255.255.255. 11 | 00 0000 -> 255.255.255.96 
		broadcast: 10.11.160. 00 | 11 1111 -> 10.11.160.63 
		gateway: 10.11.160.62 
		range: 10.11.160.0 - 10.11.160.62 
	
	K: -> 28+3 -> 31 -> 2^5 = 32 -> 5 bit -> /27
		base: 10.11.160. 010|0 0000 -> 10.11.160.64/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224
		broadcast: 10.11.160. 010|1 1111 -> 10.11.160.95
		gateway: 10.11.160.94
		range: 10.11.160.65 - 10.11.160.93
	
	A: -> 25+3 -> 28 -> 2^5 = 32 -> 5 bit -> /27
		base: 10.11.160. 011|0 0000 -> 10.11.160.96/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224
		broadcast: 10.11.160. 011|1 1111 -> 10.11.160.127 
		gateway: 10.11.160.126
		range: 10.11.160.97 - 10.11.160.125 
	
	G: -> 14+3 -> 17 -> > 2^4 -> 2^5 -> 32 -> 5 bit -> /27
		base: 10.11.160. 100|0 0000 -> 10.11.160.128/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224
		broadcast: 10.11.160. 100|1 1111 -> 10.11.160.159
		gateway: 10.11.160.158
		range: 10.11.160.129 - 10.11.160.157
	
	M: -> 9+3 -> 12 -> 2^4 -> 16 -> 4 bit -> /28
		base: 10.11.160. 1010 | 0000 -> 10.11.160.160/28
		netmask: 255.255.255. 1111 | 0000 -> 255.255.255.240
		broadcast: 10.11.160. 1010 | 1111 -> 10.11.160.175
		gateway: 10.11.160.174
		range: 10.11.160.161 - 10.11.160.173
	
Con regola dell'allineamento:
	A: -> 25+3 -> 28 -> 5 bit -> /27
		base: 10.11.160.000|0 0000 -> 10.11.160.0/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224
		broadcast: 10.11.160. 000|1 1111 -> 10.11.160.31 
		gateway: 10.11.160.1
		range: 10.11.160.2 - 10.11.160.30 
		
	G: -> 14+3 -> 17 -> 5 bit -> /27
		base: 10.11.160. 001|0 0000 -> 10.11.160.32/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224 
		broadcast: 10.11.160. 001|1 1111 -> 10.11.160.63
		gateway: 10.11.160.33
		range: 10.11.160.34 - 10.11.160.62 
		
	K: -> 28+3 -> 32 -> 5 bit -> /27
		base: 10.11.160. 010|0 0000 -> 10.11.160.64/27
		netmask: 255.255.255. 111|0 0000 -> 255.255.255.224
		broadcast: 10.11.160. 010|1 1111 -> 10.11.160.95 
		gateway: 10.11.160.65 
		range: 10.11.160.66 - 10.11.160.94
		
	M: -> 9+3 -> 12 -> 4 bit -> /28
		base: 10.11.160. 0110 | 0000 -> 10.11.160.96/28 
		netmask: 255.255.255. 1111 | 0000 -> 255.255.255.240 
		broadcast: 10.11.160. 0110 | 1111 -> 10.11.160.111
		gateway: 10.11.160.97
		range: 10.11.160.98 - 10.11.160.110 
		
	R: -> 58+3 -> 61 -> 6 bit -> /26 
		base: 10.11.160. 10|00 0000 -> 10.11.160.128/26
		netmask: 255.255.255. 11|00 0000 -> 255.255.255.192
		broadcast: 10.11.160. 10|11 1111 -> 10.11.160.191 
		gateway: 10.11.160.129
		range: 10.11.160.130 - 10.11.160.190
		

-----------------------------------------------------------------------------------------------------------------

Lezione 09 - 29/11/22 

syllabus ariel -> altri esercizi.

packet tracer.

CLI del router. Router non è plug-n-play come gli switch, quindi necessitano di essere configurati.

Per cambiare modalità di privilegi -> enable (+1) / disable (-1).

Ping ha ttl misurato in numero di hop. 

ctrl-alt-6 equivalente di ctrl-c (in linux).

traceroute google.com

telnet -> strumento di terminale remoto via rete, fa girare tutto in chiaro, se qualcuno fa sniffing sono fottuto.

ssh -> secure shell -> cifrata.

comando show -> mostra cosa fa un comando.

comando config -> verrà usato molto.

router hanno filesystem -> comando file.

aaa -> 3 regole d'oro -> authentication, authorization, accounting.

startup-config -> mostra i contenuti della configurazione di startup.

comandi ip, interfaces 

show interfaces -> informazioni su tutte le interfacce. 

config -> entro in modalità di configurazione

? -> fa vedere cosa posso configurare

interface ? -> fa vedere che interfacce posso configurare

interface FastEthernet 0/0 -> entro in config-if 

comando ip address <indirizzo> -> può essere configurato tramite dhcp o a.b.c.d/m

ip address 192.168.0.254 255.0.0.0

vanno poi messi anche i gateway predefiniti nei pc

configurazione sia per switch che per router su dispositivo in fase di configurazione delle vlan. Configurare prima le vlan, poi vlan attraverso il router. Comando write dice dove scrivere -> write mem ... -> scrive in memoria permanente

come faccio a mettere in comunicazione le vlan? devo usare il router.

modificare l'ip dei pc per far si che stiano in vlan differenti, modificare anche il gateway.

ma non va bene, devo modificare interfaccia.

conf t (configura da terminale)
interface FastEthernet 0/0 

posso dire che ha una sottointerfaccia con lo stesso vlanid che usiamo sullo switch.

interface FastEthernet 0/0.12 (12 id del rosso)

entro in configurazione della sottointerfaccia (config-subif).

encapsulation dot1Q 12 (vlanid).

ip address 192.168.0.254 255.255.255.0 

configuro ciascuna sottointerfaccia per vlan con ipaddress.

//seminario su robe


------------------------------------------------------------------------------------------------------

Lezione 10 - 02/12/22

Continuando sul file della scorsa volta in pt.

Switch viene usato per rompere i domini di broadcast, ma allo stesso tempo partizioniamo i domini di broadcast sotto lo stesso switch (?)

Come faccio a passare da un dominio di broadcast all'altro? Gli switch non sono in grado di farlo, dobbiamo passare per forza da un router. 

Colleghiamo gli switch tra di loro, possono gestire le vlan senza troppi problemi -> una vlan che ha delle sottovlan.

Configurare vlan -> conf t -> eccetera.

Abbiamo compilato excel, creato struttura, aggiunte vlan ai database, collegato in access le porte degli switch ai relativi host con modalità accesss alla vlan, trunk tra i due switch, colleghiamo al router in trunk lo switch.

Salvare configurazione degli switch -> write memory -> salva.

Router CLI -> interface FastEthernet 4/0.numvlan -> sottointerfaccia -> encapsulation dot1Q numvlan -> ip address 192.168.0.254 255.255.255.0 -> no shutdown -> exit

Robe su server dhcp (discover). 

Server dhcp nella rete. Ha k indirizzi dinamici da assegnare.

Proxy -> ARP proxy -> procuratore -> configurare il router perchè opera come DHCP proxy -> nella CLi del router:
enable -> conf t -> interface FastEthernet 4/0.numvlan (della vlan senza dhcp server) -> ip helper-address indirizzoserverdestinazione -> ovvero: ip helper-address 192.168.1.3 .

Tutti i server hanno indirizzi statici.

Rotte statiche -> pt.

host -> desktop -> command prompt per testare ping.

Contare quante reti conosce un router per capire se ho configurato bene o meno.

Creazione rotte statiche (slide) attraverso router via cli -> modalità privilegiata, configurare le rotte -> 
ip route <prefissodestinazione> <netmask> <vicino> <metrica, di default numero di hop>
questo comando va fatto per tutte le reti che questo router non conosce. 

La rotta deve essere anche settata per il ritorno poi.


----------------------------------------------------------------------------------------------------

Lezione 11 - 06/12/22

Packet tracer, griglia anche.

Se ogni host fa ping con il suo router le lan sono ok. Facciamo write mem per ogni router.

Poi in cli: router 0 
 
ip route 192.168.10.0 255.255.255.0 192.168.0.2 
ip route 192.168.20.0 255.255.255.0 192.168.0.6
ip route 192.168.0.8 255.255.255.252 192.168.0.2

per ogni router fare routing dell'ip a ip adatto e poi altro.

show ip route mostra cose.

se il collegamento tra due router va giu, non abbiamo più modo per far passare dati, in quanto ha rotta statica.

Dobbiamo usare instradamento dinamico -> rip oppure ospf 

router0 -> routing -> static -> remove tutte quante.
 per
Come configuriamo rip? 

cli di router0 -> conf t -> comando router -> fa partire process di routing -> router <algoritmo di instradamento> -> 
router rip -> entro in sottomodulo di configurazione (come al solito ? per i comandi)
di default siamo in versione 1, quindi netmask è settata a 24 senza esplicitarla 
ci interessa di più il comando network <indirizzo base rete> -> network 192.168.1.0 
network 192.168.0.0

//diciamo al router che deve annunciare le reti che conosce

router1 -> router rip -> network 192.168.10.0 , network 192.168.0.0 

router2 -> router rip -> network 192.168.20.0 , network 192.168.0.0

CAMBIAMENTI HANNO EFFETTO SOLO ALL'USCITA DELLA MODALITA' DI SOTTOCONFIGURAZIONE.

Se ispezioniamo routing table del router0, ora dovrebbe conoscere 6 reti, ma ne conosce 7, infatti ha capito che c'è un altro percorso per raggiungere il router 2. (S per statico, R per rip).

Se simulo un guasto, dovrebbero riuscire a mandare i messaggi comunque, grazie ai distance vector che vengono mandati e dunque viene imparato un nuovo cammino. 

Per utilizzare rip in versione classless:
cancellare per ogni router le rotte rip v1 (config, rip, remove su tutte). 

router0 -> 
conf t 
router rip 
//cambia nel sottomodulo di configurazione
version 2
//annunciamo le reti 
network 192.168.1.0 //rete a cui è connesso il router	
network 192.168.0.0 //r0-r1
network 192.168.0.4 //r0-r2

//router con versioni diverse non si possono parlare!

Non vogliamo che vengano mandati i distance vector sulla lan 192.168.0.0

router 0 -> conf t -> router rip -> passive-interface FastEthernet0/0 (interfaccia della rete normale). 

E così per gli altri router. In questo modo non vengono mandati distance vector agli host, ma solo ai router. 

OSPF: scelta algoritmo di routing e destinazioni a cui applicarlo

[slide]

wildcard e netmask sommate devono dare 255.255.255.255. (wildcard è la negazione della mask, qualsiasi sia la mask).

router 0 -> conf t -> router ospf 1 -> area 1 stub -> 
network 192.168.1.0 0.0.0.255 area 1
					^ bit di wildcard
networl 192.168.0.0 0.0.0.3 area 1
network 192.168.0.4 0.0.0.3 area 1 

stessa cosa per gli altri 2 router:
router1 -> conf t -> router ospf 1 -> area 1 stub ->
//sue 3 reti vanno annunciate 
network 192.168.10.0 0.0.0.255 area 1
network 192.168.0.0 0.0.0.3 area 1 
network 192.168.0.8 0.0.0.3 area 1 

router2 -> conf t -> router ospf 1 -> area 1 stub ->
network 192.168.20.0 0.0.0.255 area 1
network 192.168.0.4 0.0.0.3 area 1
network 192.168.0.8 0.0.0.3 area 1

si scambiano i messaggi e dopo un po' compariranno i cammini OSPF. 


--------------------------------------------------------------------------------------------------------------------

Lezione 12 - 13/12/22

//ultimo argomento di packet tracer: ACL e NAT 

Per setup della rete: //sub
host con gateway uguale a ip dell'interfaccia del router. Aggiungere vlan allo switch. Fare gateway per ciascuna vlan e settare quei gateway come indirizzi ip delle sottointerfacce dell'interfaccia del router. Mettere in trunk il collegamento tra router e switch e mettere in access con specifica vlan il collegamento tra host e switch. Fare ping ICMP per testare. 

ACL -> Access Control List -> meccanismo per controllare accessi alla rete.

ACL sono applicate su un'interfaccia sola, con scopo di limitare traffico in ingresso o in uscita. 

ACL standard (ID 1-99) -> seleziono solo IP sorgente dei pacchetti da non fare passare

ACL extended (ID 100-199) -> posso selezionare:
	- protocollo di livello network o trasporto
	- indirizzo sorgente e/o destinazione //wildcard any
	- (insiemi di) porte //e quindi servizi well-known
	- modalità permit/deny 
	- established -> segmenti TCP con ack flag a 1 (dal secondo passo del threeway handshake)

ACL named extended -> come extendend, ma modificabili successivamente.

Server -> services -> http -> on -> possiamo anche editare la pagina

configurazione di access list:

Router -> conf t -> access-list 110 permit ? -> access-list 110 permit tcp any host 192.168.200.200 (//server) eq 80 (//equal to porta 80, quella del web) 
access-list 110 permit tcp any host 192.168.200.200 eq 80 

Al di fuori della modalità di conf posso fare show access-lists -> mostra numero di riga

conf t -> access-list 110 deny ICMP any any 

Le righe della ACL sono numerate, perchè la prima cosa che fa il router è guardare le ACL in ordine di identificatore recente e confronta le caratteristiche del pacchetto con riga per riga quelle contenute nella ACL.

Apparato di livello 3 che guarda caratteristiche di livello 4 (relativo a livello 7). Gateway capiscono dettagli di livello più alto, router no. 

Nella ACL c'è una riga implicita che fa: <deny IP any any> -> ovvero è come il default di uno switch -> qualsiasi cosa che non matcha un'altra riga della ACL, allora sicuramente butta via il pacchetto. A tale scopo se amministratore di rete deve poter accedere, deve aggiungere un'ultima riga che dice <permit IP hostadmin any>. 
 
Andiamo in CLI del router -> conf t -> interface FastEthernet 0/0 -> ip access-group 110 in (//o out) 
ovvero applico i filtri della ACL 110 a tutto ciò che è in ingresos nella FastEthernet 0/0. 

In questo modo il pc a sinistra può andare sul web e accedere alle porte, ma non può fare ping a nessuno nella rete. 

Si può vedere testando i ping con simple PDU e andando sul browser dell'host e vedere che può accedere alle pagine dall'indirizzo ip del server http://192.168.200.200.

Si possono anche ottenere informazioni sul traffico del router facendo -> show ip interface FastEthernet 0/0 .

Aggiunto server privato (acl2.pkg) e aggiunto alla relativa lan.

Router -> interface FastEthernet 0/0 -> no ip access-group 110 in (tolgo access-list) 

access-list -> per le named extended access list. 

Da config -> ip access-list extended 120  (creazione ACL, poi si entra in sottomodulo) 

da sottomodulo config-ext-nacl (config extended named acl) -> 
Vogliamo che chiunque arrivi al nostro server pubblico -> permit tcp any host 192.168.200.200 eq 80
deny IP any any 
exit

E lo applichiamo al router su cui vogliamo sia applicata -> interface FastEthernet 0/0 -> ip access-group 120 in 

Non vogliamo che arrivano al server privato e a quello ci pensa il deny IP any any. 

In questo modo possiamo accedere al server pubblico (alla porta 80) e non possiamo fare nient'altro. 

Aggiungiamo server in internet, host lo raggiunge da 10.0.0.3 in browser. 

Se un host delle VLAN invece chiede accesso al server di internet, non riesce a raggiungerlo. 

Le richieste riescono a uscire dalla lan, ma le response del server vengono bloccate dalla acl settata a in sull'interfaccia FastEthernet 0/0 del router. 

Il pacchetto tcp di risposta va verso la porta 1025 (del browser web) e dunque non riesce a passare oltre la ACL (in quanto non va sulla porta 80). 

Per farlo passare: sfruttiamo il threeway handshake, i segmenti che passano avranno il flag di ack alzato. 

In router -> conf t -> ip access-list extended 120 -> entro in sottoconfigurazione
-> 15 permit tcp any any established (ovvero permette passaggio di tcp se è una connessione stabilita)
-> exit, exit -> show ip access-list per vedere la regola 

E poi testiamo usando il web browser degli host interni alla LAN. 


NAT -> nat.pkt -> faccio remove delle acl -> no ip access-list extended 120 -> rimossa 

Configurazione di NAT: diciamo quale interfaccia è interna e quale è esterna 
Per noi interna è 1/0, esterna è 0/0 

router -> conf t -> interface FastEthernet 1/0 -> ip nat inside , interface FastEthernet 0/0 -> ip nat outside .

Stabiliamo poi una acl -> access-list 130 permit IP any any 

Specifichiamo nel router che quello che esce deve essere rimarcato con il nostro indirizzo. 

ip nat inside source list 130 interface FastEthernet 0/0 (//diciamo che prende le reogle dalla acl e mappa sull'interfaccia esterna 0/0)

forse sta roba va fatta anche per ogni sub del router -> dire che ciascuna subinterface è inside.

Dobbiamo aggiungere un port forwarding -> mappaggio statico. Indirizzo interno viene fatto corrispondere (staticamente) a un indirizzo esterno. 

interface FastEthernet 0/0

ip nat inside source static tcp 192.168.200.200 80 10.0.0.1 80 




---------------------------------------------------------------------------------------------

Lezione 13 - 16/12/22

//javasocket? Java SE doc - libro -> introduzione alla programmazione client-server 

programmazione event-driven -> operazioni di un programma dipendono da un input ricevuto dalla rete che può arrivare in un qualsiasi momento. 

modello -> definizione funzionale del comportamento di un sistema.

modello client-server -> presuppone esistenza di due entità: client richiede un servizio, server eroga un servizio. 

server deve usare il paradigma AAA -> Authentication, Authorization, Accounting.

processi sul medesimo host:
- C -> pipe, FIFO (named pipe), memoria condivisa.
- Java -> RMI (remote method invocation), CORBA (common object request broker architecture).
- Socket -> più flessibili -> bidirezionali, comunicazioni tra più parti, diversi tipi di servizi (con connessione o meno). 

processi su host differenti: 
- Socket.


Socket: insieme di comandi che permettono di rihciedere i servizi dei protocolli della rete e modificarne il comportamento. Multiplexing sullo stesso host. 

[slide]

Porte effimere -> quelle utilizzate dai client, porte dinamiche assegnate dal SO, grazie alla quale insieme all'ip il client si presenta al server. 

Socket -> presa elettrica -> punto a cui ci si collega per usufruire di servizio (scambio dati).
Socket -> libreria di funzioni (metodi / system call) che permettono di accedere ai servizi di kernel di SO per la rete (forniscono API).

socket: dominio -> determina contesto in cui si vuole suare la socket.

Dominio Unix: per comunicazione tra processi sul medesimo host (indirizzamento tramite pathname).

Dominio internet: dà accesso ai servizi di TCP/UDP/IP (usa indirizzamento di rete).

Addressing: connessione tra 2 processi invece che tra 2 host. 

distinzione tra diversi processi src/dest di dati su un host. 

Non cablare porte sotto le 1024. 

Port: ID unico legato al processo 
	- well know per servizi standard (Da 0 a 1023). 
	- in TCP/IP unsigned short.
	- registered per servizi di rete (Da 1024 a 49151) 
	- dynamic (liberamente usabili) (Da 49152 a 65535)

Il server deve esistere a un indirizzo facilmente individuabile. Tutti i servizi web si trovano alla porta 80. -> Ip + più porta 80. 

Il client si presenta al server con il proprio indirizzo nel momento in cui lo contatta (?). 

Socket definita da una quintupla:
	<protocollo, IP(src), port(src), IP(dest), port(dest)>
	
protocollo viene definito a creazione socket -> creazione di una struttura di SO. 

Indirizzo locale definito quando si lega (binding) la socket al processo che la usa. Indirizzo peer -> dipende da modello e tipo servizio. 

myariel (?)

- 

Package java.net 
SocketAddress è la sovraclasse.

InetAddress -> classe che rappresenta generico indirizzo IP.
InetSocketAddress -> classe che implementa IP socket (indirizzo IP + numero di porta). Può anche essere hostname + numero di porta.

InetAddress non ha costruttori. InetAddress manipola i resource record dei DNS, dunque dobbiamo richiedere al DNS di restituirci un oggetto di tipo InetAddress. 

https://docs.oracle.com/javase/7/docs/api/java/net/InetAddress.html

getAllByName -> ritorna tutti gli indirizzi IP associati a quel nome simbolico. 

getLocalHost ritorna la seconda riga di /etc/hosts, ovvero il nome simbolico con cui mi presento in internet e il relativo indirizzo. 

L13 folder. 

nslookup per lookup del nameserver.

[slide]


--------------------------------------------------------------------------------

Lezione 14 - 20/12/22	

InetSocketAddress.

In java 3 classi per creare canali di comunicazione:
	- DatagramSocket -> canale di comunicazione che non sarà mai connesso a nessun'altro (?). 
	- Socket -> 
	- ServerSocket -> socket passiva, lato server. 

Socket attiva -> terminale di comunicazione lato client, è lui che inizia l'interazione quando deve contattare il server. Client prende un indirizzo di rete e chiede al server quello di cui ha bisogno. 

Lato server di una connessione è la parte passiva, sempre esistente e in attesa che qualcuno gli chieda qualche cosa. 

Lato server la prima cosa che fa è mettersi in listen -> si mette in attesa e crea una coda piccola (64 posti di solito) in cui risiedono le richieste di connessione (i segmenti di SYN della prima fase del threeway handshake, segmenti con SYN bit a 1 e ACK bit a 0).
Dopodichè il server chiama una system call o metodo accept -> processo viene messo in wait finchè non arriva un segmento SYN nella coda (da parte di TCP, che fa parte del kernel del SO).

esempio1.java

[slide]

socket: tipi di serviizo: 
- connection-oriented 
- connection-less 

Connectionless: fasi di comunicazione:
Server | creazione socket -> scambio dati 
Client | creazione socket -> scambio dati -> chiusura canale (?)

Connection-oriented: fasi di comunicazione:
Server | creazione socket -> ricezione connessione -> scambio dati -> chiusura canale (torna a ricezione connessione)
Client | creazione socket -> richiesta connessione -> scambio dati -> chiusura canale 

Primitive di servizio TCP [slide]

Classe Socket -> ha un bel po' di costruttori. https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html






































 





